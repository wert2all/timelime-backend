package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	appContext "timeline/backend/app/context"
	entEvent "timeline/backend/ent/event"
	"timeline/backend/graph/convert"
	"timeline/backend/graph/model"
)

// Authorize is the resolver for the authorize field.
func (r *mutationResolver) Authorize(ctx context.Context) (*model.User, error) {
	userEntity, error := r.Models.Users.Authorize(appContext.GetUserID(ctx))
	if error != nil {
		return nil, error
	}
	timelines, error := r.Models.Timeline.GetUserTimelines(userEntity)
	if error != nil {
		return nil, error
	}
	return convert.ToUser(userEntity, timelines, appContext.GetIsNew(ctx)), nil
}

// AddTimeline is the resolver for the addTimeline field.
func (r *mutationResolver) AddTimeline(ctx context.Context, timeline *model.AddTimeline) (*model.ShortUserTimeline, error) {
	userEntity, error := r.Models.Users.GetUser(appContext.GetUserID(ctx))
	if error != nil {
		return nil, error
	}

	created, error := r.Models.Timeline.CreateTimeline(timeline.Name, userEntity)
	if error != nil {
		return nil, error
	}
	return convert.ToShortTimeline(created), nil
}

// AddEvent is the resolver for the addEvent field.
func (r *mutationResolver) AddEvent(ctx context.Context, event model.TimelineEventInput) (*model.TimelineEvent, error) {
	timeline, error := r.Models.Timeline.GetUserTimeline(appContext.GetUserID(ctx), event.TimelineID)
	if error != nil {
		return nil, error
	}

	var eventType entEvent.Type
	if event.Type == nil {
		eventType = entEvent.Type(model.TimelineTypeDefault)
	} else {
		eventType = entEvent.Type(event.Type.String())
	}

	eventEntity, error := r.Models.Event.Create(event.Date, eventType)
	if error != nil {
		return nil, error
	}

	updatedEntity, error := r.Models.Event.Update(eventEntity.Update().SetTitle(*event.Title).SetDescription(*event.Description))
	if error != nil {
		return nil, error
	}

	_, error = r.Models.Timeline.AttachEvent(timeline, updatedEntity)
	if error != nil {
		return nil, error
	}
	return convert.ToEvent(updatedEntity), nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	panic(fmt.Errorf("not implemented: Todos - todos"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
